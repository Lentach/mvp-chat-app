# Terminal 2
cd frontend && flutter run -d chrome
```

### 3. Test: Single Friend Request Acceptance

**Setup:**
- Dwóch użytkowników: alice@example.com, bob@example.com
- Alice wysyła zaproszenie do Bob
- Bob widzi zaproszenie w FriendRequestsScreen

**Test (Mobile):**
1. Bob klika "Accept"
2. **Oczekiwane:** FriendRequestsScreen się zamyka
3. **Oczekiwane:** ChatDetailScreen otwiera się z Alice
4. **Oczekiwane:** Bob może wysłać wiadomość do Alice
5. **Oczekiwane:** Alice (jeśli online) widzi konwersację na liście

**Test (Desktop - width ≥600px):**
1. Bob klika "Accept"
2. **Oczekiwane:** FriendRequestsScreen się zamyka
3. **Oczekiwane:** Konwersacja z Alice pojawia się selected w lewym panelu
4. **Oczekiwane:** Prawy panel pokazuje embedded chat z Alice
5. **Oczekiwane:** Bob może wysłać wiadomość

### 4. Test: Mutual Auto-Accept

**Setup:**
- Alice wysyła zaproszenie do Bob
- Bob wysyła zaproszenie do Alice (zanim zobaczy zaproszenie od Alice)
- Backend auto-akceptuje oba zaproszenia

**Test:**
1. **Oczekiwane (Alice):** Chat z Bob otwiera się automatycznie
2. **Oczekiwane (Bob):** Chat z Alice otwiera się automatycznie
3. **Oczekiwane:** Oboje mogą wysyłać wiadomości

### 5. Test: Offline Sender

**Setup:**
- Alice (offline) wysłała zaproszenie do Bob
- Bob akceptuje

**Test:**
1. Bob akceptuje zaproszenie
2. **Oczekiwane:** Bob widzi chat z Alice
3. Alice wraca online
4. **Oczekiwane:** Alice widzi konwersację z Bob na liście (bez auto-open, bo była offline)
5. **Oczekiwane:** Alice może kliknąć i wysłać wiadomość

### 6. Console Verification

**Backend logs (npm run start:dev):**
- Sprawdź brak błędów TypeORM
- Sprawdź brak błędów Socket.IO
- Powinny być logi typu: "Friend request accepted", "Conversation created"

**Frontend DevTools console:**
- Sprawdź brak błędów Flutter
- Sprawdź brak błędów WebSocket
- Sprawdź że eventy `friendRequestAccepted`, `openConversation`, `conversationsList` są odbierane

### 7. Database Verification

Po akceptacji zaproszenia, sprawdź w PostgreSQL:
```sql
-- Sprawdź że konwersacja istnieje
SELECT * FROM conversations WHERE
  (user_one_id = <alice_id> AND user_two_id = <bob_id>) OR
  (user_one_id = <bob_id> AND user_two_id = <alice_id>);

-- Sprawdź że zaproszenie ma status ACCEPTED
SELECT * FROM friend_requests WHERE
  (sender_id = <alice_id> AND receiver_id = <bob_id>) OR
  (sender_id = <bob_id> AND receiver_id = <alice_id>);
```

---

## Edge Cases Handled

1. **Rapid multiple acceptances:** Flaga `_navigatingToChat` zapobiega double-navigation
2. **Offline sender:** Tylko accepting user widzi auto-open (sender widzi update przy reconnect)
3. **Network delays:** PostFrameCallback zapewnia że navigation dzieje się po zaktualizowaniu state
4. **Mounted checks:** Zapobiega navigation na unmounted widgets
5. **Mutual auto-accept:** Obaj użytkownicy dostają `openConversation` event

---

## Rollback Plan

Jeśli coś pójdzie nie tak:

1. **Backend rollback:** Zakomentować kod dodany w Step 1
   - Użytkownicy wrócą do ręcznego szukania konwersacji
   - Brak breaking changes

2. **Frontend rollback:** Zakomentować zmiany w Step 2 i 3
   - FriendRequestsScreen działa jak wcześniej
   - Brak auto-navigation

3. **Weryfikacja po rollbacku:**
   ```bash
   npm run build  # backend
   flutter analyze  # frontend
   ```

---

## Summary

**Total changes:**
- 2 backend modyfikacje (emit openConversation)
- 2 frontend modyfikacje (FriendRequestsScreen navigation logic)
- 1 frontend modyfikacja (ConversationsScreen await result)
- ~40-50 linii kodu

**Pattern:** Reużywa istniejący wzorzec z NewChatScreen → zero nowych konceptów

**Impact:** Znacząco lepsze UX - użytkownicy natychmiast widzą chat z nowym znajomym


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: C:\Users\Lentach\.claude\projects\C--Users-Lentach-desktop-mvp-chat-app\600f888b-3072-424f-b796-961eedce8404.jsonl